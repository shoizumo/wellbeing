/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/Dataset.js":
/*!************************!*\
  !*** ./src/Dataset.js ***!
  \************************/
/*! exports provided: Dataset */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Dataset\", function() { return Dataset; });\nclass Dataset {\n  constructor(wbData, pantheon, timeline) {\n    this.wbData = wbData;\n    this.pantheonData = pantheon;\n    this.timeline = timeline;\n\n    this.LadderArray = [];\n    this.PositiveArray = [];\n    this.NegativeArray = [];\n    this.GDPArray = [];\n    this.PantheonArray = [];\n\n\n    this.LadderScoreArray = [];\n    this.PositiveScoreArray = [];\n    this.NegativeScoreArray = [];\n    this.GDPScoreArray = [];\n    this.PantheonScoreArray = [];\n\n    this.makeWellbeingDataset();\n    this.makePantheonDataset();\n    this.sortDataset();\n  }\n\n  /* data */\n  get ladder() {\n    return this.LadderArray;\n  }\n\n  get positive() {\n    return this.PositiveArray;\n  }\n\n  get negative() {\n    return this.NegativeArray;\n  }\n\n  get gdp() {\n    return this.GDPArray;\n  }\n\n  get pantheon() {\n    return this.PantheonArray;\n  }\n\n\n  /* score */\n  get ladderScore() {\n    return this.LadderScoreArray;\n  }\n\n  get positiveScore() {\n    return this.PositiveScoreArray;\n  }\n\n  get negativeScore() {\n    return this.NegativeScoreArray;\n  }\n\n  get gdpScore() {\n    return this.GDPScoreArray;\n  }\n\n  get pantheonScore() {\n    return this.PantheonScoreArray;\n  }\n\n\n  /* max */\n  get ladderMax() {\n    return this.LadderScoreArray[0].score;\n  }\n\n  get positiveMax() {\n    return this.PositiveScoreArray[0].score;\n  }\n\n  get negativeMax() {\n    return this.NegativeScoreArray[0].score;\n  }\n\n  get gdpMax() {\n    return this.GDPScoreArray[0].score;\n  }\n\n  // get pantheonrMax() {\n  //   return this.PantheonScoreArray[0].score;\n  // }\n\n\n  /* min */\n  get ladderMin() {\n    return this.LadderScoreArray[this.LadderScoreArray.length - 1].score;\n  }\n\n  get positiveMin() {\n    return this.PositiveScoreArray[this.PositiveScoreArray.length - 1].score;\n  }\n\n  get negativeMin() {\n    return this.NegativeScoreArray[this.NegativeScoreArray.length - 1].score;\n  }\n\n  get gdpMin() {\n    return this.GDPScoreArray[this.GDPScoreArray.length - 1].score;\n  }\n\n  // get pantheonrMin() {\n  //   return this.PantheonScoreArray[this.PantheonScoreArray.length - 1].score;\n  // }\n\n\n  makeWellbeingDataset() {\n    for (let i = 0, l = Object.keys(this.wbData).length; l > i; i++) {\n      let wb = this.wbData[i];\n      let ladder = {country: wb.country, rank: wb.lRank, score: wb.ladder};\n      let positive = {country: wb.country, rank: wb.pRank, score: wb.positive};\n      let negative = {country: wb.country, rank: wb.nRank, score: wb.negative};\n      let logGdp = {country: wb.country, rank: wb.gRank, score: wb.logGdp};\n\n      this.LadderArray.push(ladder);\n      this.PositiveArray.push(positive);\n      this.NegativeArray.push(negative);\n      this.GDPArray.push(logGdp);\n\n      this.LadderScoreArray.push(ladder);\n      this.PositiveScoreArray.push(positive);\n      this.NegativeScoreArray.push(negative);\n      this.GDPScoreArray.push(logGdp);\n    }\n  }\n\n  makePantheonDataset() {\n    for (let i = 0, l = Object.keys(this.pantheonData).length; l > i; i++) {\n      let P = this.pantheonData[i];\n      let p = {country: P.country, rank: P.rank, score: P.nPeople};\n\n      this.PantheonArray.push(p);\n      this.PantheonScoreArray.push(p);\n    }\n  }\n\n  sortDataset() {\n    this.sortDesc(this.LadderArray, 'country');\n    this.sortDesc(this.PositiveArray, 'country');\n    this.sortDesc(this.NegativeArray, 'country');\n    this.sortDesc(this.GDPArray, 'country');\n    this.sortDesc(this.PantheonArray, 'country');\n\n    this.sortDesc(this.LadderScoreArray, 'rank');\n    this.sortDesc(this.PositiveScoreArray, 'rank');\n    this.sortDesc(this.NegativeScoreArray, 'rank');\n    this.sortDesc(this.GDPScoreArray, 'rank');\n    this.sortDesc(this.PantheonScoreArray, 'rank');\n  }\n\n\n  sortDesc(array, type) {\n    array.sort(function sortRank(a, b) {\n      if (a[type] < b[type]) {\n        return -1;\n      }\n      else if (a[type] > b[type]) {\n        return 1;\n      }\n      return 0;\n    });\n  }\n}\n\n\n\n//# sourceURL=webpack:///./src/Dataset.js?");

/***/ }),

/***/ "./src/InfoBord.js":
/*!*************************!*\
  !*** ./src/InfoBord.js ***!
  \*************************/
/*! exports provided: InfoBord */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InfoBord\", function() { return InfoBord; });\n/* harmony import */ var _Location__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Location */ \"./src/Location.js\");\n\n\nclass InfoBord {\n  constructor(datasetObj, locationObj) {\n    this.dataset = datasetObj;\n    this.location = locationObj;\n    this.positiveTween = '';\n    this.negativeTween = '';\n    this.gdpTween = '';\n\n\n    this.countryNameDisplayed = '';\n    this.isFirstDisplay = true;\n\n\n    const t1 = this.createRankText('Ladder');\n    const t2 = this.createRankText('Positive');\n    const t3 = this.createRankText('Negative');\n    const t4 = this.createRankText('GDP');\n\n    const s1 = this.createScoreText('Ladder');\n    const s2 = this.createScoreText('Positive');\n    const s3 = this.createScoreText('Negative');\n    const s4 = this.createScoreText('GDP');\n\n    this.svgRankText = {t1, t2, t3, t4};\n    this.svgScoreText = {s1, s2, s3, s4};\n\n\n    this.w1000 = 1000;\n\n    this.tweenWb1 = '';\n    this.tweenWb2 = '';\n    this.tweenP1 = '';\n    this.tweenP2 = '';\n\n    this.isPantheon = false;\n\n    this.infoBtn = document.getElementsByClassName('infoType');\n    this.setInfoBtn();\n\n    this.timelineSVG = $('#infoBoardTimeline')[0].children[1];\n    this.timelineDuration = 0.07;\n    this.timelineOffset = 20;\n    this.timelineYearList = [2005, 2006, 2007, 2008, 2009, 20010, 2011, 2012, 2013, 2014, 2015, 2016, 2017];\n    this.timelineOffset = 20;\n\n    this.timelineSetInterval = '';\n  }\n\n  setInfoBtn() {\n    for (let i = 0, l = this.infoBtn.length; i < l; i++) {\n      this.infoBtn[i].addEventListener('click', (e) => {\n        $(\".infoType\").removeClass(\"selectedBtn\");\n        this.infoBtn[i].classList.add(\"selectedBtn\");\n        let infoType = e.target.id.slice(4,);\n        if (infoType === 'Text') {\n          console.log('text');\n          InfoBoard.setInfoTypeText();\n        } else if (infoType === 'Piechart') {\n          console.log('piechart');\n          InfoBoard.setInfoTypePiechart();\n        } else if (infoType === 'Linechart') {\n          console.log('linechart');\n          InfoBoard.setInfoTypeLinechart();\n        } else {\n          console.log('none');\n          InfoBoard.setInfoTypeNone();\n        }\n      })\n    }\n  }\n\n  get windowWidth() {\n    return window.innerWidth;\n  }\n\n  get width() {\n    if (this.windowWidth < 680) {\n      return 320;\n    } else if (this.windowWidth >= 680 && this.windowWidth < 800) {\n      return 480;\n    } else if (this.windowWidth >= 800 && this.windowWidth < 1000) {\n      return 600;\n    } else {\n      return 800;\n    }\n  }\n\n  get height() {\n    return this.windowWidth < 1000 ? 80 : 105;\n  }\n\n\n  radius() {\n    return this.windowWidth < this.w1000 ? 40 : 48;\n  }\n\n\n  createRankText(type) {\n    let px;\n    if (this.windowWidth < this.w1000) {\n      px = \"22px\";\n    } else {\n      px = \"28px\";\n    }\n    let text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n    text.setAttributeNS(null, \"x\", '50%');\n    text.setAttributeNS(null, \"y\", '50%');\n    text.setAttributeNS(null, 'text-anchor', 'middle');\n    text.setAttributeNS(null, 'dominant-baseline', 'central');\n    text.setAttributeNS(null, \"fill\", \"#ffffff\");\n    text.setAttributeNS(null, \"font-size\", px);\n    text.setAttributeNS(null, \"class\", \"info\" + type);\n    text.setAttributeNS(null, \"id\", \"info\" + type);\n    return text;\n  }\n\n  createScoreText(type) {\n    let px;\n    if (this.windowWidth < this.w1000) {\n      px = \"12px\";\n    } else {\n      px = \"16px\";\n    }\n    let text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n    text.setAttributeNS(null, \"x\", '50%');\n    text.setAttributeNS(null, \"y\", '70%');\n    text.setAttributeNS(null, 'text-anchor', 'middle');\n    text.setAttributeNS(null, 'dominant-baseline', 'central');\n    text.setAttributeNS(null, \"fill\", \"#eeeeee\");\n    text.setAttributeNS(null, \"font-size\", px);\n    text.setAttributeNS(null, \"class\", \"info\" + type);\n    return text;\n  }\n\n  displayInfo(countryName, earth, camera, controls) {\n    this.countryNameDisplayed = countryName;\n    if (!this.isFirstDisplay) {\n      TweenMax.killAll();\n      this.positiveTween.cancel();\n      this.negativeTween.cancel();\n      this.gdpTween.cancel();\n    }\n    this.clearInfo();\n    let res = this.calcWbInfo(countryName);\n    $('#infoBoard').css({opacity: 0.8});\n    $('#infoBoardTimeline').css({opacity: 0.8});\n    $('#tooltip').css({opacity: 0.0});\n\n\n\n    if (typeof res !== 'undefined') {\n      this.displayVisualInfo(res, Object.keys(this.dataset.wbData).length);\n      this.displayTextInfo(countryName, res);  // テキストでの結果表示\n\n      if (!this.isPantheon) {\n        if ($('.infoType.selectedBtn')[0].id.slice(4,) === 'Linechart') {\n          let wellbeingType = $('.wbButton1.selectedBtn')[0].id.slice(0, -4);\n          console.log(wellbeingType);\n          this.displayTimeline(wellbeingType, countryName, this.timelineSVG, this.timelineOffset);\n        }\n      }\n    } else {\n      this.displayVisulalNoInfo();\n      this.displayTextNoInfo();\n      if (!this.isPantheon) {\n        if ($('.infoType.selectedBtn')[0].id.slice(4,) === 'Linechart') {\n          this.displayTimelineNoInfo();\n        }\n      }\n    }\n    // display pantheon data / no data\n    this.displayPantheon(countryName);\n\n    // well-beingデータがあってもなくても移動(念の為、データの有無を確認)\n    let locationResult = this.location.countrynameToLatlon(countryName);\n    if (typeof locationResult.latitude !== 'undefined') {\n      let latitude = locationResult.latitude;\n      let longitude = locationResult.longitude;\n      // Location.moveCamera(latitude, longitude);\n\n       this.location.moveCamera(latitude, longitude, earth, camera, controls);\n\n      $('#country').empty().append(countryName);\n      $('#country4').empty().append(countryName);\n    }\n  }\n\n\n  /* ulility */\n  calcWbInfo(countryName) {\n    for (let i = 0, l = Object.keys(this.dataset.wbData).length; l > i; i++) {\n      if (this.dataset.wbData[i].country === countryName) {\n        return this.dataset.wbData[i];\n      }\n    }\n  }\n\n  attrTextFontsize() {\n    const size = this.windowWidth < 1000 ? '22px' : '28px';\n    this.svgRankText.t1.setAttributeNS(null, \"font-size\", size);\n    this.svgRankText.t2.setAttributeNS(null, \"font-size\", size);\n    this.svgRankText.t3.setAttributeNS(null, \"font-size\", size);\n    this.svgRankText.t4.setAttributeNS(null, \"font-size\", size);\n  }\n\n  attrScoreFontsize() {\n    const size = this.windowWidth < 1000 ? '12px' : '16px';\n    this.svgScoreText.s1.setAttributeNS(null, \"font-size\", size);\n    this.svgScoreText.s2.setAttributeNS(null, \"font-size\", size);\n    this.svgScoreText.s3.setAttributeNS(null, \"font-size\", size);\n    this.svgScoreText.s4.setAttributeNS(null, \"font-size\", size);\n  }\n\n  putRankOrdinal(rank) {\n    let ordinal;\n    let rankStr = rank.toString();\n    rankStr = rankStr.substring(rankStr.length - 1, rankStr.length);\n    if (rankStr === '1') {\n      ordinal = 'st'\n    } else if (rankStr === '2') {\n      ordinal = 'nd'\n    } else if (rankStr === '3') {\n      ordinal = 'rd'\n    } else {\n      ordinal = 'th'\n    }\n    return ordinal;\n  }\n\n\n  clearInfo() {\n    $($('#LadderRanking').children().children()[2]).attr('r', 0.0);\n    $($('#PositiveRanking').children().children()[2]).attr('r', 0.0);\n    $($('#NegativeRanking').children().children()[2]).attr('r', 0.0);\n    $($('#GDPRanking').children().children()[2]).attr('r', 0.0);\n\n    $('.infoLadder').attr('opacity', 0.0);\n    $('.infoPositive').attr('opacity', 0.0);\n    $('.infoNegative').attr('opacity', 0.0);\n    $('.infoGDP').attr('opacity', 0.0);\n  }\n\n\n  /* visual */\n  displayRanking(type, rank, num, duration, rankText, score, scoreText) {\n    let id = '#' + type + 'Ranking';\n    let svg = $(id).children().children()[2];\n    let radius = (num - rank + 1) / num * this.radius(); // responsive\n    let rankOrdinal;\n    let scoreUnit = type === 'GDP' ? 'US$' : 'pt';\n    rankOrdinal = this.putRankOrdinal(rank);\n\n    TweenMax.fromTo(svg, duration,\n        {attr: {r: 0}},\n        {\n          attr: {r: radius},\n          ease: Power1.easeInOut,\n          onComplete: function () {\n            rankText.innerHTML = String(rank) + \"<tspan font-size='12px'>\" + rankOrdinal + \"</tspan>\";\n            $(id).children()[0].appendChild(rankText);\n            scoreText.textContent = '(' + String(score.toFixed(1)) + scoreUnit + ')';\n            $(id).children()[0].appendChild(scoreText);\n\n            $('.info' + type).attr('opacity', 1.0);\n          }\n        });\n  }\n\n\n  createPromise(type, rank, num, svgDuration, text, nextStartDuration, score, scoreText) {\n    let promise;\n    let timeout;\n    promise = new Promise((resolve) => {\n      timeout = setTimeout(() => {\n        resolve(this.displayRanking(type, rank, num, svgDuration, text, score, scoreText));\n      }, nextStartDuration)\n    });\n    return {\n      promise: promise,\n      cancel: function () {\n        clearTimeout(timeout);\n        // isClicked = false;\n      }\n    };\n  }\n\n\n  displayVisualInfo(countryWbData, wbLength) {\n    this.attrTextFontsize();\n    this.attrScoreFontsize();\n    new Promise((resolve) => {\n      resolve(this.displayRanking('Ladder', countryWbData['lRank'], wbLength, 1.0, this.svgRankText.t1, countryWbData['ladder'], this.svgScoreText.s1));\n    }).then(() => {\n      this.positiveTween = this.createPromise('Positive', countryWbData['pRank'], wbLength, 1.0, this.svgRankText.t2, 500, countryWbData['positive'], this.svgScoreText.s2);\n      return this.positiveTween.promise;\n    }).then(() => {\n      this.negativeTween = this.createPromise('Negative', countryWbData['nRank'], wbLength, 1.0, this.svgRankText.t3, 500, countryWbData['negative'], this.svgScoreText.s3);\n      return this.negativeTween.promise;\n    }).then(() => {\n      this.gdpTween = this.createPromise('GDP', countryWbData['gRank'], wbLength, 1.0, this.svgRankText.t4, 500, countryWbData['gdp'], this.svgScoreText.s4);\n      this.isFirstDisplay = false;\n      return this.gdpTween.promise;\n    }).catch(() => {\n      console.error('Something wrong!')\n    });\n  }\n\n  displayVisulalNoInfo() {\n    this.attrTextFontsize();\n    this.attrScoreFontsize();\n    setTimeout(() => {\n      this.svgRankText.t1.textContent = 'No data';\n      $('#LadderRanking').children()[0].appendChild(this.svgRankText.t1);\n      this.svgRankText.t2.textContent = 'No data';\n      $('#PositiveRanking').children()[0].appendChild(this.svgRankText.t2);\n      this.svgRankText.t3.textContent = 'No data';\n      $('#NegativeRanking').children()[0].appendChild(this.svgRankText.t3);\n      this.svgRankText.t4.textContent = 'No data';\n      $('#GDPRanking').children()[0].appendChild(this.svgRankText.t4);\n\n      $('#infoLadder').attr('opacity', 1.0);\n      $('#infoPositive').attr('opacity', 1.0);\n      $('#infoNegative').attr('opacity', 1.0);\n      $('#infoGDP').attr('opacity', 1.0);\n    }, 500);\n  }\n\n\n  /* text */\n  displayTextInfo(countryName, countryWbData) {\n    let lRank = countryWbData['lRank'];\n    let pRank = countryWbData['pRank'];\n    let nRank = countryWbData['nRank'];\n    let gRank = countryWbData['gRank'];\n\n    this.fadeInfoBoardText();\n    setTimeout(() => {\n      this.tweenWb1 = TweenMax.to(\"#country2\", 1.0, {\n        opacity: 1.0,\n        onComplete: () => {\n          this.tweenWb2 = TweenMax.to(\".infoBoardContent2\", 1.0, {\n            opacity: 1.0,\n          });\n        }\n      })\n    }, 1000);\n\n    document.getElementById(\"country2\").innerHTML = countryName;\n    document.getElementById(\"Ladder2\").innerHTML = '- L : ' + lRank + this.putRankOrdinal(lRank);\n    document.getElementById(\"Positive2\").innerHTML = '- P : ' + pRank + this.putRankOrdinal(pRank);\n    document.getElementById(\"Negative2\").innerHTML = '- N : ' + nRank + this.putRankOrdinal(nRank);\n    document.getElementById(\"GDP2\").innerHTML = '- G : ' + gRank + this.putRankOrdinal(gRank);\n  }\n\n  displayTextNoInfo() {\n    this.fadeInfoBoardText();\n    setTimeout(() => {\n      this.tweenWb1 = TweenMax.to(\"#country2\", 1.0, {\n        opacity: 1.0,\n        onComplete: () => {\n          this.tweenWb2 = TweenMax.to(\".infoBoardContent2\", 1.0, {\n            opacity: 1.0,\n          });\n        }\n      })\n    }, 1000);\n\n    document.getElementById(\"country2\").innerHTML = countryNameGlobal;\n    document.getElementById(\"Ladder2\").innerHTML = 'No data';\n    document.getElementById(\"Positive2\").innerHTML = '';\n    document.getElementById(\"Negative2\").innerHTML = '';\n    document.getElementById(\"GDP2\").innerHTML = '';\n\n  }\n\n\n  /* timeline */\n  displayTimeline(type, countryName, svg, offset) {\n    this.deleteTimeline();\n    let data;\n    for (let i = 0, l = Object.keys(this.dataset.timeline).length; i < l; i++) {\n      if (this.dataset.timeline[i]['country'] === countryName) {\n        data = this.dataset.timeline[i][type];\n      }\n    }\n    let rank = this.searchTimelineRank(type, countryName);\n    const spanSize = '<span style=\"font-size: 18px;\">';\n    const spanWeight = '<span style=\"font-weight: 200;\">';\n    document.getElementById(\"country4\").innerHTML = countryName + spanWeight + ' ( ' + rank.rank + spanSize + rank.rankOrdinal + '</span>' + ' ) ' + '</span>';\n    let max, min;\n    if (type === 'ladder') {\n      max = this.dataset.ladderMax;\n      min = this.dataset.ladderMin;\n    } else if (type === 'positive') {\n      max = this.dataset.positiveMax;\n      min = this.dataset.positiveMin;\n    } else if (type === 'negative') {\n      // negativeは順位が逆\n      max = this.dataset.negativeMin;\n      min = this.dataset.negativeMax;\n    } else {\n      max = this.dataset.gdpMax;\n      min = this.dataset.gdpMin;\n    }\n    let timeLen = data.length;\n    let w = (this.width - offset * 2) / (timeLen - 1);\n    let startX, startY, endX, endY;\n\n    max = max * 1.1;\n    min = min * 0.5;\n\n\n    let i = 0;\n    let isPathFirst = true;\n    this.timelineSetInterval = setInterval(() => {\n      this.addTimelineScale(this.timelineYearList, this.timelineOffset, i);\n\n      let h = (data[i] - min) / (max - min) * this.height;\n      endX = w * i + offset;\n      endY = this.height - h;\n\n      // データが有るときのみ描画、無いときはスキップして次の点と結ぶ\n      if (data[i] !== -999) {\n        // 1回目は点のみ\n        if (isPathFirst) {\n          this.svgMarker(endX, endY, svg);\n          startX = endX;\n          startY = endY;\n          isPathFirst = !isPathFirst;\n        } else {\n          this.drawTimelinePath(startX, startY, endX, endY, this.timelineSVG);\n          startX = endX;\n          startY = endY;\n        }\n      }\n      i++;\n      if (i > timeLen - 1) {\n\n        clearInterval(this.timelineSetInterval);\n      }\n    }, this.timelineDuration * 1500);\n  }\n\n\n  drawTimelinePath(startX, startY, endX, endY, svg) {\n    // create line\n    let line = this.svgLine(startX, startY, endX, endY, svg);\n\n    // line animation\n    TweenMax.fromTo(line, this.timelineDuration,\n        {attr: {x2: startX, y2: startY}},\n        {\n          attr: {x2: endX, y2: endY},\n          ease: CustomEase.create(\"custom\", \"M0,0,C-0.024,0.402,0.456,0.48,0.5,0.5,0.622,0.556,0.978,0.616,1,1\"),\n          onComplete: () => {\n            this.svgMarker(endX, endY, svg)\n          }\n        })\n  }\n\n\n  svgLine(startX, startY, endX, endY, svg) {\n    let line = document.createElementNS('http://www.w3.org/2000/svg', 'line');\n    line.setAttribute('x1', startX);\n    line.setAttribute('y1', startY);\n    line.setAttribute('x2', endX);\n    line.setAttribute('y2', endY);\n    line.setAttribute(\"stroke\", \"#ffffff\");\n    line.setAttribute(\"stroke-width\", \"2\");\n    svg.appendChild(line);\n    return line;\n  }\n\n\n  svgMarker(x, y, svg) {\n    let marker = document.createElementNS(\"http://www.w3.org/2000/svg\", \"circle\");\n    marker.setAttribute(\"cx\", x);\n    marker.setAttribute(\"cy\", y);\n    marker.setAttribute(\"r\", '4px');\n    marker.setAttribute(\"fill\", \"#ffffff\");\n    svg.appendChild(marker);\n  }\n\n\n  searchTimelineRank(type, countryName, Data) {\n    let res = this.calcWbInfo(countryName);\n    let rankKey = type.slice(0, 1) + 'Rank';\n    let rank = res[rankKey];\n    let rankOrdinal = this.putRankOrdinal(rank);\n\n    return {rank: rank, rankOrdinal: rankOrdinal};\n  }\n\n\n  addTimelineScale(yearList, offset, index) {\n    let timelineScaleArea = document.getElementById('infoBoardTimelineScale');\n    let width = (timelineScaleArea.width.baseVal.value - offset * 2) / (yearList.length - 1);\n    let px = '10px';\n\n    let textX = String(width * index + offset) + 'px';\n    let text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n    text.setAttributeNS(null, \"x\", textX);\n    text.setAttributeNS(null, \"y\", '50%');\n    text.setAttributeNS(null, 'text-anchor', 'middle');\n    text.setAttributeNS(null, 'dominant-baseline', 'central');\n    text.setAttributeNS(null, \"fill\", \"#ffffff\");\n    text.setAttributeNS(null, \"font-size\", px);\n    text.textContent = String(yearList[index]);\n    timelineScaleArea.appendChild(text);\n  }\n\n\n  deleteTimeline() {\n    let d = $('#infoBoardTimelineSvg')[0].children;\n    let l = d.length;\n    for (let i = 0; i < l; i++) {\n      d[0].remove();\n    }\n\n    d = $('#infoBoardTimelineScale')[0].children;\n    l = d.length;\n    for (let i = 0; i < l; i++) {\n      d[0].remove();\n    }\n    clearInterval(this.timelineSetInterval);\n  }\n\n\n  displayTimelineNoInfo() {\n    this.deleteTimeline();\n\n    setTimeout(() => {\n      let text = document.createElementNS('http://www.w3.org/2000/svg', 'text');\n      text.setAttributeNS(null, \"x\", '50%');\n      text.setAttributeNS(null, \"y\", '50%');\n      text.setAttributeNS(null, 'text-anchor', 'middle');\n      text.setAttributeNS(null, 'dominant-baseline', 'central');\n      text.setAttributeNS(null, \"fill\", \"#ffffff\");\n      text.setAttributeNS(null, \"font-size\", '25px');\n      text.textContent = 'No data';\n      document.getElementById('infoBoardTimelineSvg').appendChild(text);\n    }, 500);\n  }\n\n\n  /* pantheon */\n  displayPantheon(countryName) {\n    let infoBoardContent3 = document.getElementsByClassName('infoBoardContent3');\n    let pIndex = -1;\n    let url;\n    let name;\n    let occupation;\n    let year;\n    const path1 = '<a href=http://pantheon.media.mit.edu/people/';\n    const path2 = ' target=\"_blank\"> - ';\n    const path3 = '</a>';\n    const born = '<span style=\"font-size: 12px;\"> born in </span>';\n    const space = '<span style=\"font-size: 12px;\"> </span>';\n\n    for (let i = 0, l = Object.keys(this.dataset.pantheonData).length; l > i; i++) {\n      if (this.dataset.pantheonData[i]['country'] === countryName) {\n        pIndex = i;\n      }\n    }\n    document.getElementById(\"country3\").innerHTML = countryName;\n    let numPanheonPeople = 5;\n    for (let i = 0; numPanheonPeople > i; i++) {\n      infoBoardContent3[i].innerHTML = ''; // clear previous result\n    }\n    if (pIndex !== -1) {\n      let d = this.dataset.pantheonData[pIndex];\n      for (let i = 0; d['name'].length > i; i++) {\n        url = d['url'][i];\n        name = d['name'][i];\n        occupation = d['occ'][i];\n        year = d['year'][i];\n        infoBoardContent3[i].innerHTML = path1 + url + path2 + name + ' <span style=\"color:#dae1f7; font-size: 16px;\">(' + space + occupation + born + year + space + ')</span>' + path3;\n      }\n    } else {\n      infoBoardContent3[0].innerHTML = 'No data';\n    }\n\n    this.fadeInfoBoardPantheon();\n    setTimeout(() => {\n      this.tweenP1 = TweenMax.to(\"#country3\", 1.0, {\n        opacity: 1.0,\n        onComplete: () => {\n          $('.infoBoardContent3').css(\"display\", 'block');\n          this.tweenP2 = TweenMax.to(\".infoBoardContent3\", 1.0, {\n            opacity: 1.0,\n          });\n        }\n      })\n    }, 1000);\n  }\n\n\n  setInfoTypeText() {\n    $('#infoBoard').css(\"display\", 'none');\n    $('#infoBoard2').css(\"display\", 'block');\n    $('#infoBoardTimeline').css(\"display\", 'none');\n\n    $(\".infoType\").removeClass(\"selectedBtn\");\n    this.infoBtn[0].classList.add(\"selectedBtn\");\n  };\n\n  setInfoTypePiechart() {\n    $('#infoBoard').css(\"display\", 'grid');\n    $('#infoBoard2').css(\"display\", 'none');\n    $('#infoBoardTimeline').css(\"display\", 'none');\n\n    $(\".infoType\").removeClass(\"selectedBtn\");\n    this.infoBtn[1].classList.add(\"selectedBtn\");\n  };\n\n  setInfoTypeLinechart() {\n    $('#infoBoard').css(\"display\", 'none');\n    $('#infoBoard2').css(\"display\", 'none');\n    $('#infoBoardTimeline').css(\"display\", 'grid');\n\n\n    $(\".infoType\").removeClass(\"selectedBtn\");\n    this.infoBtn[2].classList.add(\"selectedBtn\");\n  };\n\n  setInfoTypeNone() {\n    $('#infoBoard').css(\"display\", 'none');\n    $('#infoBoard2').css(\"display\", 'none');\n    $('#infoBoardTimeline').css(\"display\", 'none');\n\n    $(\".infoType\").removeClass(\"selectedBtn\");\n  };\n\n\n  fadeInfoBoardVisual() {\n    $('#infoBoard').css({opacity: 0.0});\n    this.fadeInfoBoardLinechart();\n  };\n\n  fadeInfoBoardText() {\n    $('#country2').css({opacity: 0.0});\n    $('.infoBoardContent2').css({opacity: 0.0});\n    this.fadeInfoBoardPantheon();\n  };\n\n  fadeInfoBoardPantheon() {\n    $('#country3').css({opacity: 0.0});\n    $('.infoBoardContent3').css({opacity: 0.0}).css(\"display\", 'none');\n  };\n\n  fadeInfoBoardLinechart() {\n    $('#infoBoardTimeline').css({opacity: 0.0});\n  };\n\n}\n\n\n\n//# sourceURL=webpack:///./src/InfoBord.js?");

/***/ }),

/***/ "./src/Location.js":
/*!*************************!*\
  !*** ./src/Location.js ***!
  \*************************/
/*! exports provided: Location */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Location\", function() { return Location; });\n// 特別3dオブジェクトは初期化に使わず\n// scene.getObjectByName( \"objectName\", true )\n// などで、その都度取得する感じにする？\n\n\n\nclass Location {\n  // constructor(latlon, earthObj, controlsObj, cameraObj) {\n  constructor(latlon) {\n    this.data = latlon;\n    this.numData = Object.keys(latlon).length;\n\n    // this.earth = earthObj;\n    // this.controls = controlsObj;\n    // this.camera = cameraObj;\n\n    const pinRadius = 0.0025;\n    this.pinSphereRadius = 0.01;\n    this.pinHeight = 0.025;\n\n\n    this.center = new THREE.Vector3(0, 0, 0);\n    this.pinMaterial = new THREE.MeshPhongMaterial({color: 0xf15b47});\n    this.pinConeGeometry = new THREE.ConeBufferGeometry(pinRadius, this.pinHeight, 16, 1, true);\n    this.pinSphereGeometry = new THREE.SphereBufferGeometry(this.pinSphereRadius, 60, 60);\n\n    this.pinList = [];\n\n    this.isMoveCamera = false;\n  }\n\n\n  countrynameToLatlon(countryName) {\n    let latitude;\n    let longitude;\n\n    for (let i = 0; this.numData > i; i++) {\n      if (this.data[i].country === countryName) {\n        latitude = this.data[i].latitude;\n        longitude = this.data[i].longitude;\n      }\n    }\n    return {latitude: latitude, longitude: longitude};\n  }\n\n  // static moveCamera(latitude, longitude) {\n  //   let targetPos = Location.convertGeoCoords(latitude, longitude);\n  //   let targetVec = targetPos.sub(this.center);\n  //   let prevVec = camera.position.sub(this.center);\n  //\n  //   let crossVec = prevVec.clone().cross(targetVec).normalize();\n  //   let angle = prevVec.angleTo(targetVec);\n  //\n  //   let q = new THREE.Quaternion();\n  //   let step = 100;\n  //   let stepAngle = angle / step;\n  //   let count = 0;\n  //   let moveCameraQuaternion = function (stepAngle) {\n  //     q.setFromAxisAngle(crossVec, stepAngle);\n  //     camera.position.applyQuaternion(q);\n  //     camera.lookAt(0.0, 0.0, 0.0);\n  //     count++\n  //   };\n  //\n  //   let id = setInterval(function () {\n  //     earth.rotation.y = 0;\n  //     // isMoveCamera = true;\n  //     controls.enableRotate = false;\n  //     moveCameraQuaternion(stepAngle);\n  //     if (count > step - 1) {\n  //       this.createPin(latitude, longitude);\n  //       clearInterval(id);\n  //       // isMoveCamera = false;\n  //       // if (!isTravelAuto) {\n  //       //   this.controls.enableRotate = true;\n  //       // }\n  //     }\n  //   }, 1000 / step);\n  // }\n\n\n  moveCamera(latitude, longitude, earth, camera, controls) {\n    // const earth\n    // const camera\n    // const controls\n\n    let targetPos = this.convertGeoCoords(latitude, longitude);\n    let targetVec = targetPos.sub(this.center);\n    let prevVec = camera.position.sub(this.center);\n\n    let crossVec = prevVec.clone().cross(targetVec).normalize();\n    let angle = prevVec.angleTo(targetVec);\n\n    let q = new THREE.Quaternion();\n    let step = 100;\n    let stepAngle = angle / step;\n    let count = 0;\n    let moveCameraQuaternion = function (stepAngle) {\n      q.setFromAxisAngle(crossVec, stepAngle);\n      camera.position.applyQuaternion(q);\n      camera.lookAt(0.0, 0.0, 0.0);\n      count++\n    };\n\n    let id = setInterval(() => {\n      earth.rotation.y = 0;\n      this.isMoveCamera = true;\n      controls.enableRotate = false;\n      moveCameraQuaternion(stepAngle);\n      if (count > step - 1) {\n        this.createPin(earth, latitude, longitude);\n        clearInterval(id);\n        this.isMoveCamera = false;\n        // if (!isTravelAuto) {\n          controls.enableRotate = true;\n        // }\n      }\n    }, 1000 / step);\n  }\n\n\n  convertGeoCoords(latitude, longitude, radius = 1.0) {\n    let latRad = latitude * (Math.PI / 180);\n    let lonRad = -longitude * (Math.PI / 180);\n\n    let x = Math.cos(latRad) * Math.cos(lonRad) * radius;\n    let y = Math.sin(latRad) * radius;\n    let z = Math.cos(latRad) * Math.sin(lonRad) * radius;\n    return new THREE.Vector3(x, y, z);\n  }\n\n  createPin(earth, latitude = 0, longitude = 0) {\n    const pin = this.makePinObj();\n    let latRad = latitude * (Math.PI / 180);\n    let lonRad = -longitude * (Math.PI / 180);\n\n    pin.position.copy(this.convertGeoCoords(latitude, longitude));\n    pin.rotation.set(0.0, -lonRad, latRad - Math.PI * 0.5);\n    pin.name = 'pin';\n    this.pinList.push(pin);\n    earth.add(pin);\n  }\n\n  makePinObj() {\n    let cone = new THREE.Mesh(this.pinConeGeometry, this.pinMaterial);\n    cone.position.y = this.pinHeight * 0.5;\n    cone.rotation.x = Math.PI;\n\n    let sphere = new THREE.Mesh(this.pinSphereGeometry, this.pinMaterial);\n    sphere.position.y = this.pinHeight * 0.95 + this.pinSphereRadius;\n\n    let group = new THREE.Group();\n    group.add(cone);\n    group.add(sphere);\n    return group;\n  }\n\n\n  deletePin(earth) {\n    for (let i = 0, l = this.pinList.length; l > i; i++) {\n      earth.remove(this.pinList[i]);\n    }\n    this.pinList = [];\n  }\n\n\n}\n\n\n\n//# sourceURL=webpack:///./src/Location.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Dataset__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Dataset */ \"./src/Dataset.js\");\n/* harmony import */ var _Location__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Location */ \"./src/Location.js\");\n/* harmony import */ var _InfoBord__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./InfoBord */ \"./src/InfoBord.js\");\n\n\n\n\n\n(() => {\n\n\n\n  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n  // クラス用の設定\n  /*\n  // setting well-being data, pantheon data\n  */\n\n  // let GDPArray = [];\n  // let LadderArray = [];\n  // let PositiveArray = [];\n  // let NegativeArray = [];\n  // let GDPScoreArray = [];\n  // let LadderScoreArray = [];\n  // let PositiveScoreArray = [];\n  // let NegativeScoreArray = [];\n  //\n  // let PantheonArray = [];\n  // let PantheonScoreArray = [];\n  //\n  //\n  // for (let i = 0, l = Object.keys(wbData).length; l > i; i++) {\n  //   let wb = wbData[i];\n  //   let ladder = {country: wb.country, rank: wb.lRank, score: wb.ladder};\n  //   let positive = {country: wb.country, rank: wb.pRank, score: wb.positive};\n  //   let negative = {country: wb.country, rank: wb.nRank, score: wb.negative};\n  //   let logGdp = {country: wb.country, rank: wb.gRank, score: wb.logGdp};\n  //\n  //   LadderArray.push(ladder);\n  //   PositiveArray.push(positive);\n  //   NegativeArray.push(negative);\n  //   GDPArray.push(logGdp);\n  //\n  //   LadderScoreArray.push(ladder);\n  //   PositiveScoreArray.push(positive);\n  //   NegativeScoreArray.push(negative);\n  //   GDPScoreArray.push(logGdp);\n  // }\n  //\n  // for (let i = 0, l = Object.keys(pantheon).length; l > i; i++) {\n  //   let P = pantheon[i];\n  //   let p = {country: P.country, rank: P.rank, score: P.nPeople};\n  //\n  //   PantheonArray.push(p);\n  //   PantheonScoreArray.push(p);\n  // }\n  //\n  // sortDesc(LadderArray, 'country');\n  // sortDesc(PositiveArray, 'country');\n  // sortDesc(NegativeArray, 'country');\n  // sortDesc(GDPArray, 'country');\n  // sortDesc(PantheonArray, 'country');\n  //\n  // sortDesc(LadderScoreArray, 'rank');\n  // sortDesc(PositiveScoreArray, 'rank');\n  // sortDesc(NegativeScoreArray, 'rank');\n  // sortDesc(GDPScoreArray, 'rank');\n  // sortDesc(PantheonScoreArray, 'rank');\n  //\n  // function sortDesc(array, type) {\n  //   array.sort(function sortRank(a, b) {\n  //     if (a[type] < b[type]) {\n  //       return -1;\n  //     }\n  //     else if (a[type] > b[type]) {\n  //       return 1;\n  //     }\n  //     return 0;\n  //   });\n  // }\n\n\n  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n  /////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n  // function countrynameToLatlon(countryName) {\n  //   let latitude;\n  //   let longitude;\n  //\n  //   for (let i = 0; latLength > i; i++) {\n  //     if (latlon[i].country === countryName) {\n  //       latitude = latlon[i].latitude;\n  //       longitude = latlon[i].longitude;\n  //     }\n  //   }\n  //   return {latitude: latitude, longitude: longitude};\n  // }\n  //\n  // /* dring move, rotate is not enable */\n  // function moveCamera(latitude, longitude) {\n  //   let targetPos = convertGeoCoords(latitude, longitude);\n  //   let targetVec = targetPos.sub(center);\n  //   let prevVec = camera.position.sub(center);\n  //\n  //   let crossVec = prevVec.clone().cross(targetVec).normalize();\n  //   let angle = prevVec.angleTo(targetVec);\n  //\n  //   let q = new THREE.Quaternion();\n  //   let step = 100;\n  //   let stepAngle = angle / step;\n  //   let count = 0;\n  //   let moveCameraQuaternion = function (stepAngle) {\n  //     q.setFromAxisAngle(crossVec, stepAngle);\n  //     camera.position.applyQuaternion(q);\n  //     camera.lookAt(0.0, 0.0, 0.0);\n  //     count++\n  //   };\n  //\n  //   let id = setInterval(function () {\n  //     earth.rotation.y = 0;\n  //     isMoveCamera = true;\n  //     controls.enableRotate = false;\n  //     moveCameraQuaternion(stepAngle);\n  //     if (count > step - 1) {\n  //       createPoint(latitude, longitude);\n  //       clearInterval(id);\n  //       isMoveCamera = false;\n  //       if (!isTravelAuto) {\n  //         controls.enableRotate = true;\n  //       }\n  //     }\n  //   }, 1000 / step);\n  // }\n  //\n  //\n  // function convertGeoCoords(latitude, longitude, radius = 1.0) {\n  //   let latRad = latitude * (Math.PI / 180);\n  //   let lonRad = -longitude * (Math.PI / 180);\n  //\n  //   let x = Math.cos(latRad) * Math.cos(lonRad) * radius;\n  //   let y = Math.sin(latRad) * radius;\n  //   let z = Math.cos(latRad) * Math.sin(lonRad) * radius;\n  //   return new THREE.Vector3(x, y, z);\n  // }\n  //\n  //\n  // /* marker pin */\n  // let pinList;\n  // let pinRadius;\n  // let pinSphereRadius;\n  // let pinHeight;\n  // let pinMaterial;\n  // let pinConeGeometry;\n  // let pinSphereGeometry;\n  //\n  // pinRadius = 0.0025;\n  // pinSphereRadius = 0.01;\n  // pinHeight = 0.025;\n  // pinConeGeometry = new THREE.ConeBufferGeometry(pinRadius, pinHeight, 16, 1, true);\n  // pinSphereGeometry = new THREE.SphereBufferGeometry(pinSphereRadius, 60, 60);\n  //\n  // function createPin() {\n  //   pinMaterial = new THREE.MeshPhongMaterial({color: 0xf15b47});\n  //   let cone = new THREE.Mesh(pinConeGeometry, pinMaterial);\n  //   cone.position.y = pinHeight * 0.5;\n  //   cone.rotation.x = Math.PI;\n  //\n  //   let sphere = new THREE.Mesh(pinSphereGeometry, pinMaterial);\n  //   sphere.position.y = pinHeight * 0.95 + pinSphereRadius;\n  //\n  //   let group = new THREE.Group();\n  //   group.add(cone);\n  //   group.add(sphere);\n  //   return group;\n  // }\n  //\n  // pinList = [];\n  //\n  // function createPoint(latitude = 0, longitude = 0) {\n  //   const pin = createPin();\n  //   let latRad = latitude * (Math.PI / 180);\n  //   let lonRad = -longitude * (Math.PI / 180);\n  //\n  //   pin.position.copy(convertGeoCoords(latitude, longitude));\n  //   pin.rotation.set(0.0, -lonRad, latRad - Math.PI * 0.5);\n  //   pin.name = 'pin';\n  //   pinList.push(pin);\n  //   earth.add(pin);\n  // }\n  //\n  // function deletePin(earth) {\n  //   for (let i = 0, l = pinList.length; l > i; i++) {\n  //     earth.remove(pinList[i]);\n  //   }\n  //   pinList = [];\n  // }\n\n  /* three objects */\n  let scene;\n  let camera;\n  let controls;\n  let ambientLight;\n  let directionalLight1;\n  let directionalLight2;\n  let renderer;\n  let geometry;\n  let material;\n  let earth;\n  let earthOutline;\n  let radius = 0.994;\n  let axesHelper;\n  const RENDERER_PARAM = {\n    clearColor: 0x000000\n  };\n\n\n\n  // function moveCamera(latitude, longitude) {\n  //   let targetPos = Location.convertGeoCoords(latitude, longitude);\n  //   let targetVec = targetPos.sub(this.center);\n  //   let prevVec = camera.position.sub(this.center);\n  //\n  //   let crossVec = prevVec.clone().cross(targetVec).normalize();\n  //   let angle = prevVec.angleTo(targetVec);\n  //\n  //   let q = new THREE.Quaternion();\n  //   let step = 100;\n  //   let stepAngle = angle / step;\n  //   let count = 0;\n  //   let moveCameraQuaternion = function (stepAngle) {\n  //     q.setFromAxisAngle(crossVec, stepAngle);\n  //     camera.position.applyQuaternion(q);\n  //     camera.lookAt(0.0, 0.0, 0.0);\n  //     count++\n  //   };\n  //\n  //   let id = setInterval(function () {\n  //     earth.rotation.y = 0;\n  //     // isMoveCamera = true;\n  //     controls.enableRotate = false;\n  //     moveCameraQuaternion(stepAngle);\n  //     if (count > step - 1) {\n  //       this.createPin(latitude, longitude);\n  //       clearInterval(id);\n  //       // isMoveCamera = false;\n  //       // if (!isTravelAuto) {\n  //       //   this.controls.enableRotate = true;\n  //       // }\n  //     }\n  //   }, 1000 / step);\n  // }\n\n  const datasetdObj = new _Dataset__WEBPACK_IMPORTED_MODULE_0__[\"Dataset\"](wbData, pantheon, timeline);\n  // const locationObj = new Location(latlon, earth, controls, camera);\n  const locationObj = new _Location__WEBPACK_IMPORTED_MODULE_1__[\"Location\"](latlon);\n\n  const infoBordObj = new _InfoBord__WEBPACK_IMPORTED_MODULE_2__[\"InfoBord\"](datasetdObj, locationObj);\n\n\n  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n  // Data canvas //\n  class HistCanvas {\n    constructor() {\n      this.histArea = document.querySelector(\"#histgram\");\n      this.context = this.histArea.getContext(\"2d\");\n      // this.setCanvasSize();\n      this.context.globalAlpha = 1.0;  // for safari(fillStyle alpha doesn't work)\n\n      const histgram = $('#histgram');\n      this.histArea.width = histgram.width();\n      this.histArea.height = histgram.height();\n      this.previousWidth = histgram.width();\n\n      this.tooltipHist = $('#tooltipHist');\n      this.mouseOnCountry = '';\n      this.histArea.addEventListener('mousemove', this.getCanvasColor.bind(this), false);\n    }\n\n    get width() {\n      return this.histArea.width;\n    }\n\n    get height() {\n      return this.histArea.height;\n    }\n\n    set width(w) {\n      this.histArea.width = w;\n      this.previousWidth = w;\n    }\n\n    getCanvasColor(event) {\n      let eventLocation = this.getEventLocation(this.histArea, event);\n      // let context = this.getContext('2d');\n      let pixelData = this.context.getImageData(eventLocation.x, eventLocation.y, 1, 1).data;\n\n      // if nofill, isInfoObject = false\n      isInfoObject = (pixelData[0] > 0);\n      isFillHist = (pixelData[0] > 0);\n    }\n\n    getEventLocation(element, event) {\n      let pos = this.getElementPosition(element);\n      return {\n        x: (event.pageX - pos.x),\n        y: (event.pageY - pos.y)\n      };\n    }\n\n\n    getElementPosition(obj) {\n      let curleft = 0, curtop = 0;\n      if (obj.offsetParent) {\n        do {\n          curleft += obj.offsetLeft;\n          curtop += obj.offsetTop;\n        } while (obj = obj.offsetParent);\n        return {x: curleft, y: curtop};\n      }\n      return undefined;\n    }\n\n    // setAlpha(alpha) {\n    //   this.globalAlpha = alpha;\n    // }\n\n\n    setNomalColor() {\n      this.context.fillStyle = \"rgb(100, 100, 100)\";\n    }\n\n    setHighlightColor() {\n      this.context.fillStyle = \"rgb(150, 50, 50)\";\n    }\n  }\n\n\n\n  // Hist class //\n  class Hist {\n    constructor(dataArray, scoreArray, type) {\n      this.data = dataArray;\n      this.scoreData = scoreArray;\n      this.type = type;\n\n      this.infoBordObj = infoBordObj;\n\n      this.canvas = new HistCanvas();\n      this.highlightedBarList = [];\n\n      this.canvas.histArea.addEventListener('mousemove', this.onHistRanking.bind(this), false);\n      this.canvas.histArea.addEventListener('mouseout', this.outHistRanking.bind(this), false);\n      this.canvas.histArea.addEventListener('click', this.clickHistRanking.bind(this), false);\n\n    }\n\n    get max() {\n      return this.scoreData[0].score;\n    }\n\n    get min() {\n      return this.scoreData[this.scoreData.length - 1].score;\n    }\n\n    resetHighlightedBarList() {\n      highlightedBarList = [];\n    }\n\n    drawHist(duration, drawType) {\n      this.resetHighlightedBarList();\n\n      /* drawType: new, redraw */\n      console.log('drawWbHist', this.type);\n      clearInterval(drawSetInterval);\n      this.histLoop(this.data, duration, drawType);\n\n      // well-being typeが変わるとき(=draw hist時)にinfoも書き直す(time line->pie chartのときにtweenが無効になるため)\n      if (typeof countryNameDisplayed !== 'undefined') {\n        if (drawType === 'new') {\n          if (!isTravelAuto) {\n            locationObj.deletePin(earth);\n            // this.infoBordObj.displayInfo(countryNameDisplayed);\n          }\n        }\n      }\n    };\n\n    histLoop(data, duration, drawType) {\n      console.log(this.type);\n      this.canvas.context.clearRect(0, 0, 9000, this.canvas.height);\n      let numData = data.length;\n      let width = this.histWidth;\n\n      // draw histogram with loop rect\n      let i = 0;\n      // console.log(numData, data);\n      drawSetInterval = setInterval(() => {\n        this.fillBar(width, i);\n        i++;\n\n        if (i > numData - 1) {\n          clearInterval(drawSetInterval);\n          this.highlightRedrawHist(drawType)\n        }\n      }, duration / numData);\n      isHistDisplay = true;\n    }\n\n    get histWidth() {\n      return this.mathFloor(this.canvas.width / this.data.length, 5);\n    }\n\n    fillBar(width, i) {\n      this.canvas.setNomalColor();\n      // this.canvas.setAlpha(0.5);\n      let max = this.type === 'negative' ? this.min : this.max;\n      let h = (this.data[i].score) / max * this.canvas.height;\n      this.canvas.context.fillRect(width * i, this.canvas.height - h, width, h);\n    }\n\n    highlightRedrawHist(drawType) {\n      if (drawType === 'redraw') {\n        this.redrawHighlightedBar(this.highlightedBarList, this.data);\n      }\n    }\n\n    mathFloor(value, base) {\n      let b = Math.pow(10, base);\n      return Math.floor(value * b) / b;\n    }\n\n    redrawHighlightedBar(indexList, data) {\n      let h;\n      for (let i = 0; indexList.length > i; i++) {\n        // highlight color\n        this.canvas.setHighlightColor();\n        let max = this.type === 'negative' ? this.min : this.max;\n        h = (data[indexList[i]].score) / max * this.canvas.height;\n        this.canvas.context.fillRect(this.histWidth * indexList[i], this.canvas.height - h, this.histWidth, h);\n      }\n    }\n\n    highlightBar(countryName) {\n      let h;\n      let index;\n      for (let i = 0, l = this.data.length; l > i; i++) {\n        if (this.data[i].country === countryName) {\n          index = i;\n          this.highlightedBarList.push(i)\n        }\n      }\n      // highlight color\n      this.canvas.setHighlightColor();\n      let max = this.type === 'negative' ? this.min : this.max;\n      h = (this.data[index].score) / max * this.canvas.height;\n      this.canvas.context.fillRect(this.histWidth * index, this.canvas.height - h, this.histWidth, h);\n    }\n\n\n    onHistRanking(event) {\n      if (this.getSelectedTypeFromButton() === this.type) {\n        // console.log('onHist', isFillHist);\n        if (isHistDisplay) {\n          if (isFillHist) {\n            let rect = event.target.getBoundingClientRect();\n            let mouseX = Math.abs(event.clientX - rect.left);\n            let index = Math.floor(mouseX / this.histWidth);\n\n            document.getElementById(\"canvasWrapper\").classList.add(\"canvasWrapperPointer\");\n            // console.log(index);\n            this.canvas.mouseOnCountry = this.data[index]['country'];\n            this.canvas.tooltipHist[0].innerText = this.canvas.mouseOnCountry;\n            this.canvas.tooltipHist.css({opacity: 1.0});\n\n            this.canvas.tooltipHist.css({top: event.clientY * 0.95});\n            this.canvas.tooltipHist.css({left: event.clientX * 1.0 - this.canvas.tooltipHist.width() / 2 - 5});\n\n          } else {\n            document.getElementById(\"canvasWrapper\").classList.remove(\"canvasWrapperPointer\");\n            this.canvas.tooltipHist.css({opacity: 0.0});\n            this.canvas.tooltipHist.css({top: 0});\n            this.canvas.tooltipHist.css({left: 0});\n          }\n        }\n      }\n    }\n\n    outHistRanking() {\n      this.canvas.tooltipHist.css({opacity: 0.0});\n    }\n\n    clickHistRanking() {\n      if (this.getSelectedTypeFromButton() === this.type) {\n        if (!isTravelAuto) {\n          if (isFillHist) {\n            // if (!isMoveCamera) {\n              console.log('click', this.canvas.mouseOnCountry, this.type);\n              locationObj.deletePin(earth);\n              console.log(this.type);\n              this.infoBordObj.displayInfo(this.canvas.mouseOnCountry);\n              console.log('conducted', this.type);\n            // }\n          }\n        }\n      }\n    }\n\n    getSelectedTypeFromButton() {\n      let type = $('.wbButton1.selectedBtn')[0].id.slice(0, -4)\n      if (typeof type === 'undefined') {\n        type = 'pantheon'\n      }\n      return type\n    }\n\n  }\n\n\n  const ladderData = new Hist(datasetdObj.ladder, datasetdObj.ladderScore, 'ladder', infoBordObj);\n  const positiveData = new Hist(datasetdObj.positive, datasetdObj.positiveScore, 'positive', infoBordObj);\n  const negativeData = new Hist(datasetdObj.negative, datasetdObj.negativeScore, 'negative', infoBordObj);\n  const gdpData = new Hist(datasetdObj.gdp, datasetdObj.gdpScore, 'gdp', infoBordObj);\n  const pantheonData = new Hist(datasetdObj.pantheon, datasetdObj.pantheonScore, 'pantheon', infoBordObj);\n\n  const dataList = {ladderData, positiveData, negativeData, gdpData, pantheonData};\n\n\n  ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n  ///////////////////////\n  /* Declare variables */\n  ///////////////////////\n\n  /* global */\n  let canvasWidth = null;\n  let canvasHeight = null;\n  let targetDOM = null;\n  let devicePixelRatio = 1;\n  // let devicePixelRatio = window.devicePixelRatio;\n  let isSP;\n  let userAgent;\n\n\n\n\n  /* texture */\n  let earthMap;\n  let earthMapLoader;\n\n\n  /* shader */\n  const clock = new THREE.Clock();\n  let time = 0.0;\n\n\n  /* well-being data */\n\n  const wbLength = Object.keys(wbData).length;\n  const latLength = Object.keys(latlon).length;\n  const pantheonLength = Object.keys(pantheon).length;\n  let meshList;\n  let wbButton;\n  let searchArray;\n  let travelModeSwitch;\n  let isTravelAuto = false;\n  let infoType;\n  let infoBtn;\n  let isTouchInfoObject = false;\n  let isSPBtnDisplay = true;\n\n\n  /* ranking histogram */\n  let isHistDisplay = false;\n  let travelIndex = 0;\n  let highlightedBarList;\n\n\n  /* interactive land function */\n  let countryNameGlobal = 0;\n  let countryNameDisplayed;\n  // let isClicked = false;\n  let dragFlag = false;\n  let isLand = false;\n  let isInfoObject = false;\n  let isFillHist = false;\n  let infoObject;\n  let isSearching = false;\n  let isFirstClick = true;\n  let latitude;\n  let longitude;\n  let isFinishStartTween = false;\n  // let isMoveCamera = false;\n  let isMoveStop = true;\n\n\n  /* init tween */\n  let initEarthPosition = new THREE.Vector3(0.0, -1.1, 1.0);\n  let initCameraPosition = new THREE.Vector3(0.0, 0.0, 2.0);\n  // let center = new THREE.Vector3(0, 0, 0);\n\n\n  /* rendering */\n  let frame = 0;\n  let speed = 3.141592 * 2 / 90 / 60 / 60;  // 1round/90m\n  let postprocessing = {};\n  // temp val\n  let stats;\n\n  let isPantheon;\n\n  /* function */\n  let travelWellbeing;\n  let travelPantheon;\n  let travelSetInterval;\n  let stopTravel;\n  let drawSetInterval;\n  let timelineSetInterval;\n\n\n  let returnSelectedWBtype;\n  let setSelectedWBButton;\n\n  // let tweenTextCountryW;\n  // let tweenTextCountryP;\n  // let tweenTextContentsW;\n  // let tweenTextContentsP;\n  let killTweenTextAnimation;\n\n\n  /////////////////\n  /* Entry point */\n  /////////////////\n  window.addEventListener('load', () => {\n\n\n    /* menu */\n    $('.navToggle').click(function () {\n      $(this).toggleClass('active');\n\n      if ($(this).hasClass('active')) {\n        $('.globalMenu').addClass('active');\n      } else {\n        $('.globalMenu').removeClass('active');\n      }\n    });\n\n    // if content is clicked, close menu.\n    $('.globalMenu').click(function () {\n      $('.navToggle').removeClass('active');\n      $('.globalMenu').removeClass('active');\n    });\n\n\n    /* modal window */\n    let menuSetting = document.getElementsByClassName('menu');\n    for (let i = 0, l = menuSetting.length; i < l; i++) {\n      menuSetting[i].addEventListener('click', (e) => {\n        let id = e.target.id.slice(4,);\n        $(undefined).blur();\n        if ($(\"#modalOverlay\")[0]) {\n          return false;\n        }\n        $(\"body\").append('<div id=\"modalOverlay\"></div>');\n        $(\"#modalOverlay\").fadeIn(400);\n\n        // contentごとに書き換え\n        $(\"#modalContentWrapper\" + id.toString()).fadeIn(400);\n        $(\"#modalOverlay, .modalClose\").unbind()\n            .click(function () {\n              $(\"#modalContentWrapper\" + id.toString() + \", #modalOverlay\").fadeOut(400, function () {\n                $(\"#modalOverlay\").remove();\n              });\n            });\n      }, false);\n    }\n\n\n    /* setting info type */\n    // infoBtn = document.getElementsByClassName('infoType');\n    // for (let i = 0, l = infoBtn.length; i < l; i++) {\n    //   infoBtn[i].addEventListener('click', (e) => {\n    //     $(\".infoType\").removeClass(\"selectedBtn\");\n    //     infoBtn[i].classList.add(\"selectedBtn\");\n    //     infoType = e.target.id.slice(4,);\n    //     if (infoType === 'Text') {\n    //       console.log('text');\n    //       InfoBoard.setInfoTypeText();\n    //     } else if (infoType === 'Piechart') {\n    //       console.log('piechart');\n    //       InfoBoard.setInfoTypePiechart();\n    //     } else if (infoType === 'Linechart') {\n    //       console.log('linechart');\n    //       InfoBoard.setInfoTypeLinechart();\n    //     } else {\n    //       console.log('none');\n    //       InfoBoard.setInfoTypeNone();\n    //     }\n    //   })\n    // }\n\n    // InfoBord.setInfoTypeText = function () {\n    //   $('#infoBoard').css(\"display\", 'none');\n    //   $('#infoBoard2').css(\"display\", 'block');\n    //   $('#infoBoardTimeline').css(\"display\", 'none');\n    //\n    //   $(\".infoType\").removeClass(\"selectedBtn\");\n    //   infoBtn[0].classList.add(\"selectedBtn\");\n    // };\n    //\n    // InfoBord.setInfoTypePiechart = function () {\n    //   $('#infoBoard').css(\"display\", 'grid');\n    //   $('#infoBoard2').css(\"display\", 'none');\n    //   $('#infoBoardTimeline').css(\"display\", 'none');\n    //\n    //   $(\".infoType\").removeClass(\"selectedBtn\");\n    //   infoBtn[1].classList.add(\"selectedBtn\");\n    // };\n    //\n    // InfoBord.setInfoTypeLinechart = function () {\n    //   $('#infoBoard').css(\"display\", 'none');\n    //   $('#infoBoard2').css(\"display\", 'none');\n    //   $('#infoBoardTimeline').css(\"display\", 'grid');\n    //\n    //\n    //   $(\".infoType\").removeClass(\"selectedBtn\");\n    //   infoBtn[2].classList.add(\"selectedBtn\");\n    // };\n    //\n    // InfoBord.setInfoTypeNone = function () {\n    //   $('#infoBoard').css(\"display\", 'none');\n    //   $('#infoBoard2').css(\"display\", 'none');\n    //   $('#infoBoardTimeline').css(\"display\", 'none');\n    //\n    //   $(\".infoType\").removeClass(\"selectedBtn\");\n    //   // infoBtn[2].classList.add(\"selectedBtn\");\n    // };\n    //\n    //\n    // InfoBord.fadeInfoBoardVisual = function () {\n    //   $('#infoBoard').css({opacity: 0.0});\n    //   InfoBord.fadeInfoBoardLinechart();\n    // };\n    //\n    // InfoBord.fadeInfoBoardText = function () {\n    //   $('#country2').css({opacity: 0.0});\n    //   $('.infoBoardContent2').css({opacity: 0.0});\n    //   InfoBord.fadeInfoBoardPantheon();\n    // };\n    //\n    // InfoBord.fadeInfoBoardPantheon = function () {\n    //   $('#country3').css({opacity: 0.0});\n    //   $('.infoBoardContent3').css({opacity: 0.0}).css(\"display\", 'none');\n    // };\n    //\n    // InfoBord.fadeInfoBoardLinechart = function () {\n    //   $('#infoBoardTimeline').css({opacity: 0.0});\n    // };\n\n\n    returnSelectedWBtype = function () {\n      return $('#wbButton2').find('.selectedBtn').attr(\"id\").slice(0, -4) + 'Data';\n    };\n\n    setSelectedWBButton = function (index) {\n      $(\".wbButton\").removeClass(\"selectedBtn\");\n      document.getElementsByClassName('wbButton1')[index].classList.add(\"selectedBtn\");\n      document.getElementsByClassName('wbButton2')[index].classList.add(\"selectedBtn\");\n    };\n\n\n    /* switch travel type button */\n    travelModeSwitch = document.getElementById('travelModeSwitch-label');\n    travelModeSwitch.addEventListener('click', () => {\n      isTravelAuto = !isTravelAuto;\n\n      // canvasContext.globalAlpha = 0.5;\n      let selectedType = returnSelectedWBtype();\n      console.log(selectedType);\n      dataList[selectedType].drawHist(2000, 'new');\n\n      infoBordObj.fadeInfoBoardVisual();\n      infoBordObj.fadeInfoBoardText();\n\n      TweenMax.killAll();\n      locationObj.deletePin(earth);\n      stopTravel();\n\n      if (isTravelAuto) {\n        isMoveStop = true;\n        controls.enableRotate = false;\n        if (!isPantheon) {\n          travelWellbeing();\n          infoBordObj.setInfoTypeText();\n        } else {\n          travelPantheon();\n        }\n        stopMove.innerText = 'Stop';\n        stopMove.setAttribute('style', 'opacity:1.0;');\n      } else {\n        isMoveStop = false;\n        controls.enableRotate = true;\n        stopMove.setAttribute('style', 'opacity:0.0;');\n        if (!isPantheon) {\n          infoBordObj.setInfoTypeLinechart();\n        } else {\n          infoBordObj.setInfoTypeNone();\n        }\n      }\n    });\n\n    let stopMove = document.getElementById('stopMove');\n    stopMove.addEventListener('click', () => {\n      if (isMoveStop) {\n        stopMove.innerText = 'Play';\n        stopTravel();\n      } else {\n        stopMove.innerText = 'Stop';\n        if (!isPantheon) {\n          travelWellbeing(travelIndex);\n        } else {\n          travelPantheon(travelIndex);\n        }\n      }\n      isMoveStop = !isMoveStop;\n    }, false);\n\n\n    /* start button */\n    let startButton = document.getElementById('startButton');\n    startButton.addEventListener('click', () => {\n      let duration = 5.0;\n      // let ease = Back.easeOut.config(1);\n      let ease = CustomEase.create(\"custom\", \"M0,0 C0.404,0.594 0.339,0.958 0.594,1.032 0.754,1.078 0.838,1 1,1\");\n\n      TweenMax.to(earth.position, duration, {\n        y: 0.0,\n        z: 0.0,\n        ease: ease\n      });\n\n      /* show button & land*/\n      TweenMax.to(camera.position, duration, {\n        z: 2.5,\n        ease: ease,\n        onComplete: function () {\n          $('.allButton').css('opacity', '1');\n\n          document.addEventListener('touchmove', function (e) {\n            e.preventDefault();\n          }, {passive: false});\n\n          setTimeout(() => {\n            setSelectedWBButton(0);\n            infoBordObj.infoBtn[2].classList.add(\"selectedBtn\"); // infoBordObj.setInfoTypeLinechart\n            infoBordObj.setInfoTypeLinechart();\n\n          }, 400);\n          setTimeout(() => {\n            // landBase.material.opacity = 1.0;\n            dataList['ladderData'].drawHist(2000, 'new');\n\n\n            isFinishStartTween = true;\n            controls.enableZoom = true;\n          }, 500);\n        }\n      });\n\n      TweenMax.to(\".load\", duration - 3.0, {\n        opacity: 0.0,\n        onComplete: function () {\n          $('.load').remove();\n        }\n      })\n    });\n\n    killTweenTextAnimation = function () {\n      if (!infoBordObj.isFirstDisplay) {\n        infoBordObj.tweenWb1.kill();\n        infoBordObj.tweenWb2.kill();\n        infoBordObj.tweenP1.kill();\n        infoBordObj.tweenP2.kill();\n      }\n    };\n\n\n    /* drag object function */\n    let draggableObject = document.getElementsByClassName(\"dragDrop\");\n    let draggableObjectX;\n    let draggableObjectY;\n\n    for (let i = 0; i < draggableObject.length; i++) {\n      draggableObject[i].addEventListener(\"mousedown\", dragMousedown, false);\n      draggableObject[i].addEventListener(\"touchstart\", dragMousedown, false);\n    }\n\n    function dragMousedown(e) {\n      let event;\n      this.classList.add(\"drag\");\n\n      // mouse & touch event\n      if (e.type === \"mousedown\") {\n        event = e;\n      } else {\n        event = e.changedTouches[0];\n      }\n      draggableObjectX = event.pageX - this.offsetLeft;\n      draggableObjectY = event.pageY - this.offsetTop;\n\n      document.body.addEventListener(\"mousemove\", dragMousemove, false);\n      document.body.addEventListener(\"touchmove\", dragMousemove, false);\n    }\n\n\n    function dragMousemove(e) {\n      let drag = document.getElementsByClassName(\"drag\")[0];\n      let event;\n\n      // mouse & touch event\n      if (e.type === \"mousemove\") {\n        event = e;\n      } else {\n        event = e.changedTouches[0];\n      }\n\n      // prevent flick\n      e.preventDefault();\n\n      drag.style.left = event.pageX - draggableObjectX + \"px\";\n      drag.style.top = event.pageY - draggableObjectY + \"px\";\n\n      drag.addEventListener(\"mouseup\", dragMouseUp, false);\n      document.body.addEventListener(\"mouseleave\", dragMouseUp, false);\n      drag.addEventListener(\"touchend\", dragMouseUp, false);\n      document.body.addEventListener(\"touchleave\", dragMouseUp, false);\n\n    }\n\n    function dragMouseUp() {\n      let drag = document.getElementsByClassName(\"drag\")[0];\n      if (typeof drag !== 'undefined') {\n        document.body.removeEventListener(\"mousemove\", dragMousemove, false);\n        drag.removeEventListener(\"mouseup\", dragMouseUp, false);\n        document.body.removeEventListener(\"touchmove\", dragMousemove, false);\n        drag.removeEventListener(\"touchend\", dragMouseUp, false);\n\n        drag.classList.remove(\"drag\");\n      }\n    }\n\n\n    /*\n    // initial setting\n    */\n    canvasWidth = window.innerWidth;\n    canvasHeight = window.innerHeight;\n    targetDOM = document.getElementById('webgl');\n\n\n    /* device check */\n    userAgent = navigator.userAgent;\n    if (userAgent.indexOf('iPhone') > 0 || userAgent.indexOf('Android') > 0 && userAgent.indexOf('Mobile') > 0) {\n      isSP = true;\n    }\n\n\n    /* window size setting */\n    window.addEventListener('resize', () => {\n      renderer.setPixelRatio(devicePixelRatio);\n      renderer.setSize(window.innerWidth, window.innerHeight);\n      camera.aspect = window.innerWidth / window.innerHeight;\n      camera.updateProjectionMatrix();\n      canvasWidth = window.innerWidth;\n      canvasHeight = window.innerHeight;\n\n      if (isFinishStartTween) {\n        let histWidth = $('#histgram').width();\n        if (dataList['ladderData'].canvas.previousWidth !== histWidth) {\n          // dataListのうち、1つだけ更新すればOK！？\n          dataList['ladderData'].canvas.width = histWidth;\n\n          let selectedType = returnSelectedWBtype();\n          console.log(selectedType);\n          dataList[selectedType].drawHist(2000, 'new');\n        }\n      }\n    }, false);\n\n\n    /* detect mouse drag(distinguish mouse “click” and “drag”) */\n    let dragStartPos = new THREE.Vector2();\n    let dragEndPos = new THREE.Vector2();\n\n    window.addEventListener(\"mousedown\", function (event) {\n      dragFlag = false;\n      dragStartPos.x = event.clientX;\n      dragStartPos.y = event.clientY;\n    }, false);\n\n\n    window.addEventListener(\"mouseup\", function (event) {\n      dragEndPos.x = event.clientX;\n      dragEndPos.y = event.clientY;\n      let length = Math.pow((dragEndPos.x - dragStartPos.x), 2) + Math.pow((dragEndPos.y - dragStartPos.y), 2);\n      dragFlag = length > 100;\n\n      if (dragFlag) {\n        if (isFinishStartTween) {\n          if (!isTravelAuto) {\n            if (!locationObj.isMoveCamera) {\n              infoBordObj.fadeInfoBoardText();\n              killTweenTextAnimation();\n              locationObj.deletePin(earth);\n            }\n          }\n        }\n      }\n    }, false);\n\n\n    /* touch event for SP */\n    window.addEventListener(\"touchstart\", function () {\n      if (isFinishStartTween) {\n        if (!isTravelAuto) {\n          if (!locationObj.isMoveCamera) {\n            if (isLand) {\n              infoBordObj.fadeInfoBoardText();\n              killTweenTextAnimation();\n              locationObj.deletePin(earth);\n            }\n          }\n        }\n        if (!isSearching) {\n          isTouchInfoObject = false;\n        }\n      }\n    }, false);\n\n\n    /* double tap event for SP */\n    let tapCount = 0;\n    window.addEventListener(\"touchstart\", function () {\n      // single tap\n      if (!tapCount) {\n        ++tapCount;\n\n        setTimeout(function () {\n          tapCount = 0;\n        }, 350);\n\n        // double tap\n      } else {\n        if (isSPBtnDisplay) {\n          $('#travelModeSwitch').css({'display': 'none'});\n          $('#stopMove').css({'display': 'none'});\n          $('.navToggle').css({'display': 'none'});\n        } else {\n          $('#travelModeSwitch').css({'display': 'block'});\n          $('#stopMove').css({'display': 'block'});\n          $('.navToggle').css({'display': 'block'});\n        }\n        isSPBtnDisplay = !isSPBtnDisplay;\n        e.preventDefault();\n        tapCount = 0;\n      }\n    });\n\n\n    /* load earth texture */\n    earthMapLoader = new THREE.TextureLoader();\n    if (isSP) {\n      earthMap = earthMapLoader.load('img/mapNightSP.jpg', loadShader);\n      console.log('sp')\n    } else {\n      earthMap = earthMapLoader.load('img/mapNight.jpg', loadShader);\n    }\n\n  }, false);\n\n  /* END Entry point */\n\n\n  function loadShader() {\n    SHADER_LOADER.load((data) => {\n      const vsMain = data.myShaderMain.vertex;\n      const fsMain = data.myShaderMain.fragment;\n      const vsPost = data.myShaderPost.vertex;\n      const fsPost = data.myShaderPost.fragment;\n      init(vsMain, fsMain, vsPost, fsPost);\n    })\n  }\n\n\n  /////////////////////////\n  /* Initialize function */\n\n  /////////////////////////\n  function init(vsMain, fsMain, vsPost, fsPost) {\n    stats = initStats();\n\n    function initStats() {\n      let stats = new Stats();\n      stats.setMode(0); // 0: fps, 1: ms\n      // Align top-left\n      stats.domElement.style.position = 'absolute';\n      stats.domElement.style.left = '0px';\n      stats.domElement.style.top = '200px';\n      document.getElementById(\"Stats-output\").appendChild(stats.domElement);\n      return stats;\n    }\n\n\n    /*\n    // setting three object\n    */\n    scene = new THREE.Scene();\n\n    /* renderer */\n    renderer = new THREE.WebGLRenderer({antialias: true});\n    renderer.setPixelRatio(devicePixelRatio);\n    renderer.setClearColor(new THREE.Color(RENDERER_PARAM.clearColor));\n    renderer.setSize(canvasWidth, canvasHeight);\n    targetDOM.appendChild(renderer.domElement);\n\n\n    /* camera */\n    camera = new THREE.PerspectiveCamera(60, canvasWidth / canvasHeight, 0.1, 5.0);\n    // camera.name = 'camera';  // name for Location class\n    camera.position.z = initCameraPosition.z;\n    // scene.add(camera);\n\n    controls = new THREE.OrbitControls(camera, renderer.domElement);\n    // controls.name = 'controls';  // name for Location class\n    controls.enablePan = false;\n    controls.enableZoom = false;\n    controls.minDistance = 2.0;\n    controls.maxDistance = 4.0;\n    controls.rotateSpeed = 0.1;\n    controls.enableDamping = true;\n    controls.dampingFactor = 0.2;\n    // scene.add(controls);\n\n\n    /* light for marker Pin */\n    ambientLight = new THREE.AmbientLight(0xffffff, 0.5);\n    scene.add(ambientLight);\n\n    directionalLight1 = new THREE.DirectionalLight(0xffffff, 0.5);\n    directionalLight1.position.set(5.0, 2.0, 5.0);\n    scene.add(directionalLight1);\n\n    directionalLight2 = new THREE.DirectionalLight(0xffffff, 0.5);\n    directionalLight2.position.set(-5.0, 2.0, -5.0);\n    scene.add(directionalLight2);\n\n\n    /* earth map ver. */\n    geometry = new THREE.SphereBufferGeometry(radius, 60, 60);\n    material = new THREE.RawShaderMaterial({\n      vertexShader: vsMain,\n      fragmentShader: fsMain,\n      uniforms: {\n        // Map\n        earthTex: {type: \"t\", value: earthMap},\n        time: {type: \"f\", value: time},\n        resolution: {type: \"v2\", value: [canvasWidth, canvasHeight]},\n      },\n      side: THREE.FrontSide, //DoubleSide,\n      //depthWrite: false,\n      transparent: true,\n      //opacity: 0.5,\n      //wireframe: true,\n    });\n    earth = new THREE.Mesh(geometry, material);\n    // earth.name = 'earth';  // name for Location class\n\n\n\n\n    /* earth outline object */\n    geometry = new THREE.SphereGeometry(radius + 0.003, 120, 120);\n    material = new THREE.MeshBasicMaterial({\n      color: 0x555555,\n      side: THREE.BackSide\n      // alphaTest: 0.5\n    });\n    earthOutline = new THREE.Mesh(geometry, material);\n\n    meshList = [];\n    for (let name in country_data) {\n      geometry = new Tessellator3D(country_data[name]);\n      // let continents = [\"EU\", \"AN\", \"AS\", \"OC\", \"SA\", \"AF\", \"NA\"];\n      let color = new THREE.Color().setHSL(0, 0, 0.3);\n\n      let m = country_data[name].mesh = new THREE.Mesh(\n          geometry,\n          new THREE.MeshBasicMaterial({\n            color: color,\n            transparent: true,\n            opacity: 0.0\n          }));\n      m.name = \"land\";\n      m.userData.country = name;\n\n      earth.add(m);\n      meshList.push(m);\n    }\n\n\n    /* add to scene */\n    earth.add(earthOutline);\n    scene.add(earth);\n    earth.position.y = initEarthPosition.y;\n    earth.position.z = initEarthPosition.z;\n\n    // console.log(scene.getObjectByName('earth', true));\n    // console.log(scene.getObjectByName('camera', true));\n    // console.log(scene.getObjectByName('controls', true));\n\n\n    /* make well-being button in order to show score */\n    wbButton = document.getElementsByClassName('wbButton');\n    for (let i = 0, wbLen = wbButton.length; i < wbLen; i++) {\n      wbButton[i].addEventListener('click', (e) => {\n\n        /* delete infoBoard2 */\n        killTweenTextAnimation();\n        infoBordObj.fadeInfoBoardText();\n        locationObj.deletePin(earth);\n\n        const wbType = {'ladderData': 0, 'positiveData': 1, 'negativeData': 2, 'gdpData': 3};\n        const type = e.target.id.slice(0, -4) + 'Data';\n        const index = wbType[type];\n        setSelectedWBButton(index);\n        dataList[type].drawHist(2000, 'new');\n\n        /* travel type check */\n        if (isTravelAuto) {\n          locationObj.deletePin(earth);\n          travelWellbeing();\n        }\n      }, false);\n    }\n\n\n    /* pantheon mode */\n    isPantheon = false;\n    window.addEventListener(\"keydown\", function (event) {\n      // console.log(event.keyCode, event.keyCode === 32);\n      if (!locationObj.isMoveCamera) {\n        if (event.keyCode === 32) {  // space\n          console.log('space');\n          onPantheon();\n          if (isTravelAuto) {\n            infoBordObj.fadeInfoBoardPantheon();\n            travelPantheon();\n          }\n\n        } else if (event.keyCode === 27) {\n          console.log('esc');\n          offPantheon();\n          if (isTravelAuto) {\n            stopTravel();\n            travelWellbeing();\n          }\n        }\n      }\n    }, false);\n\n\n    function onPantheon() {\n      // $('#country2').css(\"display\", 'none');\n      $('#infoBoard3').css(\"display\", 'block');\n      $(\".infoType\").removeClass(\"selectedBtn\");\n      infoBordObj.infoBtn[2].classList.add(\"selectedBtn\");\n      infoBordObj.setInfoTypeNone();\n\n      TweenMax.killAll();\n      locationObj.deletePin(earth);\n      stopTravel();\n      isPantheon = true;\n      dataList['pantheonData'].drawHist(2000, 'new');\n\n      $('#wbButton2').css(\"display\", 'none');\n    }\n\n    function offPantheon() {\n      // let selectedType = returnSelectedWBtype();\n\n      // $('#country2').css(\"display\", 'block');\n      $('#infoBoard3').css(\"display\", 'none');\n      $(\".infoType\").removeClass(\"selectedBtn\");\n\n      // もとに戻すときのinfoType設定\n      if (isTravelAuto) {\n        infoBordObj.infoBtn[0].classList.add(\"selectedBtn\");\n        infoBordObj.setInfoTypeText();\n      } else {\n        infoBordObj.infoBtn[2].classList.add(\"selectedBtn\");\n        infoBordObj.setInfoTypeLinechart();\n      }\n\n      TweenMax.killAll();\n      locationObj.deletePin(earth);\n      isPantheon = false;\n\n      let selectedType = returnSelectedWBtype();\n      console.log(selectedType);\n      dataList[selectedType].drawHist(2000, 'new');\n\n      $('#wbButton2').css(\"display\", 'block');\n    }\n\n\n    /*\n    // interactive land object function\n    */\n    let tooltip = $('#tooltip');\n    // let infoBoard = $('#infoBoard');\n    // let infoBoardTimeline = $('#infoBoardTimeline');\n    let body = $('body');\n\n    window.addEventListener('mousemove', onLandMouseMove, false);\n    window.addEventListener('click', onLandMouseClick, false);\n\n\n    /* mouse over land */\n    function onLandMouseMove(event) {\n      if (isFinishStartTween) {\n        event.preventDefault();\n        let mouseX = (event.clientX / window.innerWidth) * 2 - 1;\n        let mouseY = -(event.clientY / window.innerHeight) * 2 + 1;\n        let vector = new THREE.Vector3(mouseX, mouseY, -1);\n        vector.unproject(camera);\n        let raycaster = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());\n        let intersects = raycaster.intersectObject(earth, true);\n\n        // set tooltip not display\n        tooltip.css({opacity: 0.0});\n        isLand = false;\n        body.css('cursor', 'default');\n\n        if (isFinishStartTween) {\n          if (!isTravelAuto) {\n            if (!isInfoObject) {\n              if (!locationObj.isMoveCamera) {\n                if (intersects.length > 0) {\n                  if (intersects[0].point !== null) {\n                    if (intersects[0].object.name === \"land\") {\n\n                      countryNameGlobal = intersects[0].object.userData.country;\n                      tooltip[0].innerText = countryNameGlobal;\n                      tooltip.css({opacity: 1.0});\n                      isLand = true;\n                      body.css('cursor', 'pointer');\n                      tooltip.css({top: event.clientY * 0.97});\n                      tooltip.css({left: event.clientX * 1.03});\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n\n    /* click land */\n    function onLandMouseClick() {\n      if (isFinishStartTween) {\n        if (!dragFlag) {\n          if (isLand) {\n            locationObj.deletePin(earth);\n            infoBordObj.displayInfo(countryNameGlobal, earth, camera, controls);\n          }\n        }\n      }\n    }\n\n\n    /* detect whether onInfo or not */\n    infoObject = document.getElementsByClassName('infoObject');\n    for (let i = 0, l = infoObject.length; i < l; i++) {\n      infoObject[i].addEventListener('mouseenter', onInfoObject, false);\n      infoObject[i].addEventListener('mouseleave', outInfoObject, false);\n      infoObject[i].addEventListener('touchstart', touchInfoObject, false);\n    }\n\n\n    function onInfoObject() {\n      isInfoObject = true;\n    }\n\n    function outInfoObject() {\n      if (!isSearching) {\n        isInfoObject = false;\n      }\n    }\n\n    function touchInfoObject() {\n      isTouchInfoObject = true;\n    }\n\n\n\n    /*\n    // travel ranking country\n    */\n    travelWellbeing = function (index = 0) {\n      stopTravel();  // clear previous travel\n      let i = index;\n      travelSetInterval = setInterval(function () {\n        if (i > 0) {\n          pinList[i - 1].children[0].material.color.setHex(0xC9C7B7);\n          pinList[i - 1].children[1].material.color.setHex(0xC9C7B7);\n        }\n\n        let selectedType = returnSelectedWBtype();\n        let data = dataList[selectedType];\n        let countryName = data.scoreData[i].country;\n        data.highlightBar(countryName);\n        infoBordObj.displayInfo(countryName);\n        i++;\n        travelIndex = i;  // val for continue\n        if (i > wbLength - 1) {\n          // if (i > 3 - 1) {\n          console.log('clearInterval', i);\n          clearInterval(travelSetInterval);\n\n          // next travel\n          setTimeout(() => {\n            const wbType = {'ladderData': 1, 'positiveData': 2, 'negativeData': 3, 'gdpData': 0};\n            const type = e.target.id.slice(0, -4) + 'Data';\n            const nextIndex = wbType[type];\n            setSelectedWBButton(nextIndex);\n            dataList[type].drawHist(2000, 'new');\n\n            infoBordObj.fadeInfoBoardVisual();\n            infoBordObj.fadeInfoBoardText();\n\n            locationObj.deletePin(earth);\n            travelWellbeing();\n          }, 5000);\n        }\n      }, 3140);  // 1800(=30m) / 143(Num of well-being data) / 4\n    };\n\n\n    stopTravel = function () {\n      clearInterval(travelSetInterval);\n    };\n\n\n    /*\n    // travel pantheon\n    */\n    travelPantheon = function (index = 0) {\n      stopTravel();  // clear previous travel\n      let i = index;\n      let numPinList = 0;\n      let isClear = false;\n\n      function travel() {\n        if (i > 0) {\n          if (numPinList === pinList.length) {\n            isClear = true;\n          }\n          let pins = pinList[pinList.length - 1].children;\n          pins[0].material.color.setHex(0xC9C7B7);\n          pins[1].material.color.setHex(0xC9C7B7);\n          numPinList = pinList.length;\n        }\n\n\n        let data = dataList['pantheon'];\n        let countryName = data.scoreData[i].country;\n        data.highlightBar(countryName);\n\n\n        // let countryName = PantheonScoreArray[i]['country'];\n        // console.log(countryName);\n        // highlightedBar(countryName, histData, scoreMax);\n        let res = countrynameToLatlon(countryName);\n        latitude = res.latitude;\n        longitude = res.longitude;\n        moveCamera(latitude, longitude);\n        displayPantheon(countryName);\n        i++;\n\n        if (isClear) {\n          for (let i = 0, l = pinList.length; l > i; i++) {\n            let pins = pinList[i].children;\n            pins[0].material.color.setHex(0xC9C7B7);\n            pins[1].material.color.setHex(0xC9C7B7);\n          }\n        }\n        travelIndex = i;  // val for continue\n        if (i > pantheon.length - 1) {\n          console.log('clearInterval', i);\n          clearInterval(travelSetInterval);\n        }\n        travelSetInterval = setTimeout(travel, 9250);  // 1800(=30m) / 194(Num of Pantheon data)\n      }\n\n      // travel();\n      travelSetInterval = setTimeout(travel, 3000);  // 1800(=30m) / 194(Num of Pantheon data)\n    };\n\n\n    // helper\n    axesHelper = new THREE.AxesHelper(5.0);\n    scene.add(axesHelper);\n\n\n    /* conduct rendering */\n    if (isSP) {\n      spRender();\n    } else {\n      initPostprocessing(vsPost, fsPost);\n      render();\n    }\n\n\n    /*\n    search country name\n    */\n    searchArray = [];\n    for (let i = 0; i < latLength; i++) {\n      searchArray.push(latlon[i].country);\n    }\n    searchArray = searchArray.sort();\n\n    let selectorSearchID = [\"#country\", \"#country4\"];\n    for (let i = 0, l = selectorSearchID.length; i < l; i++) {\n      let selectorSearch = $(selectorSearchID[i]);\n      selectorSearch.autocomplete({\n        source: searchArray,\n        autoFocus: false, //defo:false\n        delay: 300,\n        minLength: 1\n      });\n\n      selectorSearch.on(\"autocompleteclose\", function () {\n        countryNameGlobal = $(selectorSearchID[i])[0].innerHTML;\n        locationObj.deletePin(earth);\n\n        console.log(countryNameGlobal);\n\n        infoBordObj.displayInfo(countryNameGlobal, earth, camera, controls);\n        isSearching = false;\n        isInfoObject = false;\n        // console.log(isInfoObject);\n      });\n\n      selectorSearch.on(\"autocompleteopen\", function () {\n        isSearching = true;\n        isInfoObject = true;\n        // console.log(isInfoObject);\n      });\n    }\n\n  }\n\n  /* END Initialize function */\n\n  ////////////////////////\n  /* Rendering function */\n\n  ////////////////////////\n  function render() {\n    // controls.update();\n    stats.update();\n    frame++;\n    earth.rotation.y += speed;\n\n    let nowTime = clock.getElapsedTime();\n    requestAnimationFrame(render);\n\n    /* set 30ftp */\n    if (frame % 2 === 0) {\n      return;\n    }\n\n    //オフスクリーンレンダリング\n    renderer.render(scene, camera, postprocessing.renderTarget);\n    //平面オブジェクト用テクスチャ画像を更新\n    postprocessing.plane.material.uniforms.texture.value = postprocessing.renderTarget.texture;\n    postprocessing.plane.material.uniforms.time.value = nowTime;\n    postprocessing.plane.material.uniforms.resolution.value = [canvasWidth * devicePixelRatio, canvasHeight * devicePixelRatio];\n\n    //平面オブジェクトをレンダリング\n    renderer.render(postprocessing.scene, postprocessing.camera);\n  }\n\n  /* Rendering function for SP */\n  function spRender() {\n    stats.update();\n    frame++;\n    earth.rotation.y += speed;\n\n    requestAnimationFrame(spRender);\n\n    /* set 30ftp */\n    if (frame % 2 === 0) {\n      return;\n    }\n    renderer.render(scene, camera);\n  }\n\n\n  /////////////////////////////\n  /* Postprocessing function */\n\n  /////////////////////////////\n  function initPostprocessing(vsPost, fsPost) {\n    time = 0.0;\n    postprocessing.scene = new THREE.Scene();\n    postprocessing.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);\n\n    postprocessing.plane = new THREE.Mesh(\n        new THREE.PlaneBufferGeometry(2, 2),\n        new THREE.RawShaderMaterial({\n          uniforms: {\n            texture: {type: \"t\", value: null},\n            resolution: {type: \"v2\", value: [canvasWidth * devicePixelRatio, canvasHeight * devicePixelRatio]},\n            time: {type: \"f\", value: time},\n          },\n          vertexShader: vsPost,\n          fragmentShader: fsPost,\n        })\n    );\n\n    postprocessing.scene.add(postprocessing.plane);\n    postprocessing.renderTarget = new THREE.WebGLRenderTarget(\n        targetDOM.clientWidth,\n        targetDOM.clientHeight,\n        {\n          minFilter: THREE.LinearFilter,\n          magFilter: THREE.LinearFilter,\n          format: THREE.RGBFormat,\n          stencilBuffer: false\n        }\n    );\n  }\n\n})();\n\n\n\n//# sourceURL=webpack:///./src/index.js?");

/***/ })

/******/ });